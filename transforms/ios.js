// iOS/Swift specific transforms
import StyleDictionary from 'style-dictionary';

export function registerIOSTransforms(SD) {
    // Name transform ONLY - convert token names to camelCase for Swift
    SD.registerTransform({
        name: 'name/ios-swift/camel',
        type: 'name',
        transform: (token) => {
            let path = [...token.path];
            
            // Remove collection name (first part)
            if (path.length > 0) path.shift();
            
            // Remove theme layer if present
            if (path.length > 0 && (path[0] === 'light-theme' || path[0] === 'dark-theme')) {
                path.shift();
            }
            
            // Convert to camelCase
            return path
                .map((part, index) => {
                    const cleaned = part.replace(/[^a-zA-Z0-9]/g, ' ').trim();
                    const words = cleaned.split(/\s+/);
                    
                    return words.map((word, wordIndex) => {
                        if (index === 0 && wordIndex === 0) {
                            return word.toLowerCase();
                        }
                        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
                    }).join('');
                })
                .join('');
        }
    });

    // Register iOS transform group - ONLY name transforms, NO value transforms
    SD.registerTransformGroup({
        name: 'ios-swift',
        transforms: [
            'attribute/cti',              // Built-in: adds category/type/item metadata
            'name/ios-swift/camel'        // Custom: converts names to camelCase
        ]
    });

    // Format function handles ALL value transformations
    SD.registerFormat({
        name: 'custom/ios-swift',
        format: ({ dictionary, options }) => {
            const className = options?.className || 'DesignTokens';
            
            let output = `// GENERATED CODE - DO NOT EDIT\n`;
            output += `// Generated by Style Dictionary\n\n`;
            output += `import UIKit\n\n`;
            output += `public enum ${className} {\n`;
            
            // Transform and output all tokens
            dictionary.allTokens.forEach(token => {
                // Detect if this is a reference or direct value
                const isReference = token.original?.value && 
                                   typeof token.original.value === 'string' && 
                                   token.original.value.startsWith('{');
                
                // Use token.value for references (already resolved), token.original.value for direct values
                const value = isReference ? token.value : (token.original?.value || token.value);
                const type = token.type;
                const pathString = token.path.join('-').toLowerCase();
                let outputValue;
                let typeAnnotation = '';
                
                // Transform based on token type (original values, not pre-transformed)
                if (type === 'color') {
                    // Check if already transformed (from reference resolution)
                    if (typeof value === 'string' && value.startsWith('UIColor(')) {
                        outputValue = value;
                    } else if (typeof value === 'string' && value.startsWith('rgba(')) {
                        // Parse RGBA format: rgba(r, g, b, a)
                        const match = value.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
                        if (match) {
                            const r = parseInt(match[1]) / 255;
                            const g = parseInt(match[2]) / 255;
                            const b = parseInt(match[3]) / 255;
                            const a = parseFloat(match[4]);
                            outputValue = `UIColor(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)}, alpha: ${a.toFixed(3)})`;
                        } else {
                            outputValue = 'UIColor.black';
                        }
                    } else {
                        // Parse hex format: #RRGGBB or #RRGGBBAA
                        const hex = value.replace('#', '');
                        const r = parseInt(hex.substr(0, 2), 16) / 255;
                        const g = parseInt(hex.substr(2, 2), 16) / 255;
                        const b = parseInt(hex.substr(4, 2), 16) / 255;
                        const a = hex.length === 8 ? parseInt(hex.substr(6, 2), 16) / 255 : 1;
                        outputValue = `UIColor(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)}, alpha: ${a.toFixed(3)})`;
                    }
                } else if (type === 'fontWeight') {
                    // Convert to UIFont.Weight
                    const weightMap = {
                        100: 'ultraLight',
                        200: 'thin',
                        300: 'light',
                        400: 'regular',
                        500: 'medium',
                        600: 'semibold',
                        700: 'bold',
                        800: 'heavy',
                        900: 'black'
                    };
                    const weight = parseInt(value);
                    outputValue = `UIFont.Weight.${weightMap[weight] || 'regular'}`;
                } else if (type === 'fontFamily') {
                    // Quote font family names
                    const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                    outputValue = `"${escaped}"`;
                } else if (type === 'lineHeight' || pathString.includes('lineheight') || pathString.includes('line-height')) {
                    // Convert line height to CGFloat unitless multiplier
                    let val;
                    
                    // Check if already transformed like 'CGFloat(1408.00)'
                    if (typeof value === 'string' && value.startsWith('CGFloat(')) {
                        const match = value.match(/CGFloat\(([\d.]+)\)/);
                        val = match ? parseFloat(match[1]) : NaN;
                    } else if (typeof value === 'string' && value.endsWith('px')) {
                        val = parseFloat(value);
                    } else {
                        val = parseFloat(value);
                    }
                    
                    if (!isNaN(val)) {
                        if (val < 10) {
                            outputValue = val.toFixed(2);
                        } else {
                            // Convert pixels to ratio using base font size (16px)
                            const ratio = val / 16;
                            outputValue = ratio.toFixed(2);
                        }
                    } else {
                        outputValue = '0.0';
                    }
                    typeAnnotation = ': CGFloat';
                } else if (type === 'dimension' || type === 'sizing' || type === 'spacing') {
                    // Convert to CGFloat
                    let num;
                    
                    // Check if already transformed like 'CGFloat(64.00)'
                    if (typeof value === 'string' && value.startsWith('CGFloat(')) {
                        const match = value.match(/CGFloat\(([\d.]+)\)/);
                        num = match ? parseFloat(match[1]) : NaN;
                    } else if (typeof value === 'number') {
                        num = value;
                    } else if (typeof value === 'string' && value.endsWith('px')) {
                        num = parseFloat(value);
                    } else {
                        num = parseFloat(value);
                    }
                    
                    outputValue = isNaN(num) ? '0.0' : num.toFixed(2);
                    typeAnnotation = ': CGFloat';
                } else if (typeof value === 'boolean') {
                    outputValue = value.toString().toLowerCase();
                } else if (typeof value === 'number') {
                    outputValue = `${value.toFixed(2)}`;
                    typeAnnotation = ': CGFloat';
                } else if (typeof value === 'string') {
                    // Check if it's a number with px
                    if (value.endsWith('px')) {
                        const num = parseFloat(value);
                        outputValue = isNaN(num) ? '0.0' : num.toFixed(2);
                        typeAnnotation = ': CGFloat';
                    } else {
                        const escaped = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                        outputValue = `"${escaped}"`;
                    }
                } else {
                    outputValue = String(value);
                }
                
                output += `    public static let ${token.name}${typeAnnotation} = ${outputValue}\n`;
            });
            
            output += `}\n`;
            return output;
        }
    });
}
